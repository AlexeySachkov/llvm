= sycl_ext_oneapi_virtual_functions

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 7 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.

This extension also depends on the following other SYCL extensions:

* link:../experimental/sycl_ext_oneapi_kernel_properties.asciidoc[
  sycl_ext_oneapi_kernel_properties]
* link:../experimental/sycl_ext_oneapi_properties.asciidoc[
  sycl_ext_oneapi_properties]
* link:../experimental/sycl_ext_oneapi_named_sub_group_sizes.asciidoc[
  sycl_ext_oneapi_named_sub_group_sizes]

== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*

== Backend support status

The APIs in this extension may be used only on a device that has
`aspect::ext_oneapi_virtual_functions`.  The application must check that the
device has this aspect before submitting a kernel using any of the APIs in this
extension.  If the application fails to do this, the implementation throws
a synchronous exception with the `errc::kernel_not_supported` error code
when the kernel is submitted to the queue.

== Overview

The main purpose of this extension is to reduce amount of SYCL language
restrictions for device code by allowing to call virtual member functions
from device functions.

NOTE: this extension **does not** cover (i.e. doesn't enable) things like
`dynamic_cast`, `typeid` or calls through function pointers.

== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_ONEAPI_VIRTUAL_FUNCTIONS` to one of the values defined in the
table below.  Applications can test for the existence of this macro to determine
if the implementation supports this feature, or applications can test the
macro's value to determine which of the extension's features the implementation
supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===

=== New language restrictions for device functions

The following restriction, listed in section 5.4 of the core SYCL specification
does not apply if this extension is supported by an implementation:

> The odr-use of polymorphic classes and classes with virtual inheritance is
> allowed. *However, no virtual member functions are allowed to be called in a
> device function.*

However, there are still some limitations of how virtual member functions can
be used:

- if an object is constructed in host code, calling a virtual member function
  for that object in device code has undefined behavior;
- if an object is constructed in device code on a device `A`, calling a virtual
  member function for that object in host code, or on another device `B` has
  undefined behavior;

=== New properties

Due to the indirect nature of virtual member functions, compiler may not be able
to understand which exact virtual member function is being called (i.e. which
class it belongs to).  Moreover, when code is distributed over several
translation units, compiler may not be able to even see definitions of all
virtual member functions which may be called in a kernel.

Therefore, to provide a mechanism for an implementation to help detect virtual
member functions, which are going to be used from kernels and enforce necessary
restrictions on them, new compile-time-constant properties are proposed.

[source,dpcpp]
----
namespace sycl::ext::oneapi::experimental {

  struct indirectly_callable_key {
    template <typename SetId>
    using value_t = property_value<indirectly_callable_key, SetId>;
  };

  struct calls_indirectly_key {
    template <typename First = void, typename... SetIds>
    using value_t = property_value<calls_indirectly_key, First, SetIds...>;
  };

  template <typename SetId = void>
  inline constexpr indirectly_callable_key::value_t<SetId> indirectly_callable;

  template <typename First = void, typename... Rest>
  inline constexpr calls_indirectly_key::value_t<First, Rest...>
      calls_indirectly;

  template <>
  struct is_property_key<indirectly_callable_key> : std::true_type {};
  template <> struct is_property_key<calls_indirectly_key> : std::true_type {};
}
----

Before describing those properties those properties in more detail, a couple of
new terms are introduced to simplify the extension specification:

Set of virtual member functions:: a group of virtual member functions which are
defined with `indirectly_callable` property with the same value of the property
parameter `SetId`. For the simplicity, this will also be further refferred to as
a set, or as a set of virtual functions.

Kernel declares a use of a set of virtual member functions:: a kernel is
considered to be declaring a use of a set of virtual member functions `SetIdA`
when it is submitted with `calls_indirectly` property with `SetIdA` included
into the property parameter `SetIds`. If `SetIdA` is not included into the
property parameter `SetIds`, or if a kernel is submitted without the property,
then it is *not* considered to be declaring a use of the set of virtual member
functions.

|===
|Property|Description
|`indirectly_callable`
|The `indirectly_callable` property indicates that a virtual member function as
a device function, thus making it available to be called from SYCL kernel and
device functions. Should only be applied to virtual member functions and to do
so, function-style `SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY` macro should
be used. It accepts a single optional argument, which is passed to the property
parameter `SetId` and therefore has all the same requirements.

Optional parameter `SetId` specifies a set of virtual member functions this
function belongs to and at the same time it defines a group of kernels, which
can call this function, it must be a C++ typename. When the parameter is
ommitted, a virtual member function is considered to belong to a default set.

Calling a virtual member function from a kernel which does not declare use of a
set the virtual member function belongs to is an undefined behavior.

|`calls_indirectly`
|The `calls_indirectly` property indicates that a SYCL kernel function is
performing calls through virtual member functions and declares use one or more
of sets of virtual member functions.

Optional parameter `SetIds` specifies which sets of virtual member functions are
declared to be used by the kernel, it must be zero or more comma-separated C++
typenames. If the argument is omitted (zero C++ typenames specified), than a
kernel is considered to be using a default set of virtual member functions.

Calling a virtual member function, which does not belong to any of sets of
virtual member functions declared to be used is an undefined behavior.
|===

If a virtual member function is called from device code, both definition and
declaration of that function must be decorated with the +indirectly_callable+
property. `SetId` property parameter must match between definition and
declaration and implementation should provide a diagnostic in case of mismatch.

Applying the +indirectly_callable+ property to a SYCL Kernel function is illegal
and an implementation should produce a diagnostic for that.

Applying the +indirectly_callable+ property to an arbitrary device function,
which is not a virtual member function has no effect.

NOTE: This behavior may be changed in either future version of this extension or
in another extensions.

Virtual member functions that are decorated with the +indirectly_callable+
property are considered to be device functions, i.e. they  must obey the
restrictions listed in section 5.4 of the core SYCL specification "Language
restrictions for device functions". Virtual member functions that are not
decorated with this attribute do not need to obey these restrictions, even if
other definitions of that virtual member function in other classes in the
inheritance hierarchy are decorated with the attribute.

[source,dpcpp]
----
using syclext = sycl::ext::oneapi::experimental;

struct set_A;
struct set_B;

class Foo {
public:
  // properties to functions should be applied using the macro:
  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY(set_A) void foo() {}

  // both declaration and definition should be annotated:
  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY(set_A) void bar();

  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY(set_B) void baz() {}
};

void SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY(set_A) Foo::bar() {}

// kernel calling virtual function should also be annotated:
/* */.single_task(syclext::properties{syclext::calls_indirectly<set_A>}, [=] {
  Foo *ptr = /* ... */;
  ptr->bar()

  // Note: this kernel can only call 'Foo::foo' and 'Foo::bar' but not
  // 'Foo::baz', because the latter is declared within a different set.
});
----

Reasons about why it may be necessary to put different virtual functions into
different sets are explained in further sections, but for simplicity purposes
both properties can be used without explicitly specifying a set, thus using
a default set:

[source,dpcpp]
----
using syclext = sycl::ext::oneapi::experimental;

struct set_A;

class Foo {
public:
  // This virtual member function belongs to a default set of virtual functions.
  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY() void foo() {}

  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY(set_A) void bar() {}
};

/* */.single_task(syclext::properties{syclext::calls_indirectly<>}, [=] {
  Foo *ptr = /* ... */;
  ptr->bar()

  // Note: this kernel can only call 'Foo::foo' but not 'Foo::bar', because the
  // latter belongs to a different (non-default) set of virtual functions.
});
----

NOTE: `void` typename is explicitly reserved as identifier of the default
virtual functions set. It can still be used, but with the expectation that it
is also implicitly used by the extension implementation.

=== Optional kernel features handling

The core SYCL specification (5.8 Attributes for device code) says the following
in the description of `device_has` attribute for SYCL kernels and non-kernel
device functions.

When the attribute is applied to a kernel:

> ... it causes the compiler to issue a diagnostic if the kernel (or any of the
> functions it calls) uses an optional feature that is associated with an aspect
> that is not listed in the attribute.

When the attribute is applied to a function:

> ... it causes the compiler to issue a diagnostic if the device function (or
> any of the functions it calls) uses an optional feature that is associated
> with an aspect that is not listed in the attribute.

Due to dynamic nature of virtual member functions, compiler in general case is
not able to perform static analysis of a call graph in order to understand which
exact virtual functions are called from which kernels.

Instead, information from the new properties is used by an implementation to
issue such diagnostic. When determining a set of aspects which are used by a
SYCL kernel function, implementation also takes into account all aspects which
are used by all virtual member functions included into all sets of virtual
member functions declared to be used by a kernel.


[source,dpcpp]
----
using syclext = sycl::ext::oneapi::experimental;

struct set_A;
struct set_B;

struct Foo {
  // This function uses 'fp64' aspect
  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY(set_A) void foo() {
    double d = 3.14;
  }

  // This function uses 'fp16' aspect
  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY(set_B) void bar() {
    sycl::half h = 2.71;
  }
};

sycl::queue q;

q.single_task(syclext::properties{syclext::calls_indirectly<set_B>},
    [=] [[sycl::device_has(sycl::aspect::fp64)]] {
  // Diagnostic is required for this kernel, because it is declared as only
  // using 'fp64' aspect, but it also uses virtual member functions from
  // "set_B", which includes 'Foo:bar' that uses 'fp16' aspect.
});

q.single_task(syclext::properties{syclext::calls_indirectly<set_A>},
    [=] [[sycl::device_has()]] {
  // Diagnostic is required for this kernel, because it is declared as not
  // using any optional features, but it also uses virtual member functions from
  // "set_A", which includes 'Foo::foo' that uses 'fp64' aspect.
});

q.single_task(syclext::properties{syclext::calls_indirectly<set_A>},
    [=] [[sycl::device_has(sycl::aspect::fp64)]] {
  // No diagnostic is required for this kernel, because list of declared aspects
  // matches list of used aspects. That includes virtual member functions from
  // "set_A", which includes 'Foo::foo' that uses 'fp64' aspect
});

q.single_task(syclext::properties{syclext::calls_indirectly<>},
    [=] [[sycl::device_has()]] {
  // No diagnostic is required for this kernel, because list of declared aspects
  // matches list of used aspects. There are no virtual member functions defined
  // in a default set, which means that no extra optional kernel features
  // requirements were attached to the kernel.
});
----

Submitting a kernel with `calls_indirectly` property, which includes virtual
member functions that use optional kernel features to a device which doesn't
support them, should result in an exception at runtime, similar to how it is
defined by the core SYCL specification.

[source,dpcpp]
----
using syclext = sycl::ext::oneapi::experimental;

struct set_A;
struct set_B;

struct Foo {
  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY(set_A) void foo() {
    double d = 3.14;
  }

  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY(set_B) void bar() {}
};

sycl::queue q(/* device selector returns a device *without* fp64 support */);
assert(!q.get_device().has(sycl::aspect::fp64));

q.single_task(syclext::properties{syclext::calls_indirectly<set_A>}, [=] {
  // Exception is expected to be thrown, because target device doesn't support
  // fp64 aspect and it is required by 'Foo::foo' which is included into 'set_A'
});

q.single_task(syclext::properties{syclext::calls_indirectly<set_B>}, [=] {
  // No exceptions are expected, because 'set_B' doesn't bring any requirements
  // for optional kernel features.
});
----

An implementation may not raise a compile time diagnostic or a run time
exception merely due to speculative compilation of a virtual member function for
a device when the application does not specify a use of virtual member functions
through the correponding properties.

[source,dpcpp]
----
using syclext = sycl::ext::oneapi::experimental;

struct Foo {
virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY() void foo() {
  double d = 3.14;
}

virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY() void bar() {}
};

sycl::queue q(/* device selector choosing a device *without* fp64 support */);
assert(!q.get_device().has(sycl::aspect::fp64));

auto *Storage = sycl::malloc_device<Foo>(1, q);

q.single_task([=] {
  // The kernel is not submitted with 'calls_indirectly' property and therefore
  // it is not considered to be using any of virtual member functions of 'Foo'.
  // This means that the object of 'Foo' can be successfully created by this
  // kernel, regardless of whether a target device supports 'fp64' aspect which
  // is used by 'Foo::foo'.
  // No exceptions are expected to be thrown.
  new (Storage) Foo;
});
----

==== Interation with `reqd_sub_group_size` attribute

The `reqd_sub_group_size` attribute is a bit of a special case comparing to
other optional kernel features, because it requires to compile a kernel in a
certain way, which may require special handling for all functions which are
called from it.

When the same helper function is called from two or more kernels
with different `reqd_sub_group_size` attribute, it may be required for the
implementation to duplicate that helper function to create different versions
of it tailored to different sub-group sizes. It can be done in a straightforward
manner when operating on a static call graph.

Virtual member functions are essentially called indirectly and pointers to them
are initialized just once when an object of a polymorhpic class is being
created. Therefore, to support calling such virtual member function from two or
more kernels with different `reqd_sub_group_size`, each kernel may need to
receive a different pointer to a different version of a virtual member function.

To avoid possibly posing such multi-versioning requirements on implementations,
virtual member functions can only be called from a kernel with _primary_
sub-group-size as defined by
link:../experimental/sycl_ext_oneapi_named_sub_group_sizes.asciidoc[
sycl_ext_oneapi_named_sub_group_sizes] extension, or otherwise behavior is
undefined.

NOTE: for implementations that don't support
`sycl_ext_oneapi_named_sub_group_sizes` extension, virtual member functions can
only be called from kernels which *don't* have `reqd_sub_group_size` attribute
set on them explicitly, or otherwise behavior is undefined.

=== Kernel bundles and device images

When an object of a polymorphic class is constructed, it stores a pointer to
virtual table, which points to its virtual member functions. Addresses of those
functions are accessible and valid only within a kernel bundle containing a
kernel which used to construct an object.

Performing calls to virtual member functions of an object constructed in a
kernel from a different kernel bundle is an undefined behavior.

[source,dpcpp]
----
using syclext = sycl::ext::oneapi::experimental;

struct Base {
  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY() void foo() {}
};

class Constructor;
class Use;

int main() {
  sycl::queue Q;

  Base *Obj = sycl::malloc_device<Base>(1, Q);
  int *Result = sycl::malloc_shared<int>(2, Q);

  auto bundleA
    = sycl::get_kernel_bundle<sycl::bundle_state::executable>(Q.get_context(),
        {sycl::get_kernel_id<Constructor>()});
  auto bundleB
    = sycl::get_kernel_bundle<sycl::bundle_state::executable>(Q.get_context(),
        {sycl::get_kernel_id<Use>()});


  Q.submit([&](sycl::handler &CGH) {
    CGH.use_kernel_bundle(bundleA);
    CGH.single_task<Constructor>(syclext::properties{syclext::calls_indirectly<>},
        [=] {
      // Only placement new can be used within device functions.
      new (Obj) Derived;
    });
  });

  Q.submit([&](sycl::handler &CGH) {
    CGH.use_kernel_bundle(bundleB);
    CGH.single_task<Use>(syclext::properties{syclext::calls_indirectly<>}, [=] {
      // Call to 'Base::foo' is an undefined behavior here, because 'Obj' was
      // constructed within kernel bundle `bundleA`
      Obj->foo();
    });
  });

  return 0;
}
----

== Example usage

[source,dpcpp]
----
#include <sycl/sycl.hpp>

using syclext = sycl::ext::oneapi::experimental;

class Base {
public:
  virtual SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY()
  int get_random_number() {
    return 4; // Chosen by fair dice roll. Guaranteed to be random
  }

  // Not considered to be a device function, can use full set of C++ features
  virtual int get_host_random_number() {
    throw std::runtime_error("Not Implemented");
  }
};

class Derived : public Base {
public:
  SYCL_EXT_ONEAPI_INDIRECTLY_CALLABLE_PROPERTY()
  int get_random_number() override {
    return 221;
  }
};

int main() {
  sycl::queue Q;

  Base *Obj = sycl::malloc_device<Derived>(1, Q);
  int *Result = sycl::malloc_shared<int>(1, Q);

  Q.single_task([=] {
    // Only placement new can be used within device functions.
    new (Obj) Derived;
  });

  auto props = syclext::properties{syclext::calls_indirectly<>};
  Q.single_task(props, [=] {
    Base B;
    Result[0] = B.get_random_number();
  }).wait();
  assert(A[0] == 4);

  Q.single_task(props, [=] {
    A[0] = Obj->get_random_number();
  }).wait();
  assert(A[0] == 221);

  return 0;
}
----
