# Implementation design for sycl_ext_oneapi_virtual_functions

Corresponding language extension specification:
[sycl_ext_oneapi_virtual_functions][1]


## Design

### Changes to the SYCL header files

New compile-time properties `indirectly_callable` and `calls_indirectly` should
be implemented in accordance with the corresponding [design document][2].

`indirectly_callable` property should lead to emission of
`"indirectly-callable"="set"` function attribute, where "set" is a string
representation of the property template parameter.

`calls_indirectly` property should lead to emission of
`"calls-indirectly"="set1,set2"`, where "set1" and "set2" are string
representations of the property template parameters.

In order to convert a type to a string, [\__builtin_sycl_unique_stable_name][3]
could be used.

**TODO**: `calls_indirectly` requires compile-time concatenation of strings.
Document how it should be done.

### Changes to the compiler front-end

Compiler front-end should be updated to respect rules defined by the
[extension specifiction][1], such as:

- virtual member functions annotated with `indirectly_callable` compile-time
  property should be emitted into device code;
- virtual member function *not* annotated with `indirectly_callable`
  compile-time property should *not* be emitted into device code;

**TODO**: investigate if it is possible to enforce SYCL device code restrctions
on virtual member functions marked with the compile-time property.

### Changes to the compiler middle-end

#### Aspects propagation and related diagnostics

Aspects propagation pass should be extended to not only gather aspects which are
used directly, but also aspects that are used indirectly, through virtual
functions.

For that the pass should compile a list of aspects used by each set of
indirectly callable functions (as defined by `indirectly_callable` property set
by user) and then append those aspects to every kernel which uses those sets.

Diagnostic should be emitted if a kernel is marked with `device_has` attribute
or property which doesn't include an indirectly used aspect.

#### Device code split and device images

The extension specification restricts implementation from raising a diagnostic
when a kernel not marked with `calls_indirectly` kernel property creates an
object of a polymorphic class where some virtual functions use optional kernel
features incompatible with a target device.

Consider the following example:

```c++
using syclext = sycl::ext::oneapi::experimental;

struct fp64_set;
struct regular_set;

struct Foo {
virtual SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(
    syclext::indirectly_callable<fp64_set>) void foo() {
  // uses double
  double d = 3.14;
}

virtual SYCL_EXT_ONEAPI_FUNCTION_PROPERTY(
    syclext::indirectly_callable<regular_set>) void bar() {}
};

sycl::queue q;

auto *Storage = sycl::malloc_device<Foo>(1, q);

q.single_task([=] {
  // The kernel is not submitted with 'calls_indirectly' property and therefore
  // it is not considered to be using any of virtual member functions of 'Foo'.
  // This means that the object of 'Foo' can be successfully created by this
  // kernel, regardless of whether a target device supports 'fp64' aspect which
  // is used by 'Foo::foo'.
  // No exceptions are expected to be thrown.
  new (Storage) Foo;
});

if (q.get_device().has(sycl::aspect::fp64)) {
  auto props = syclext::properties{syclext::calls_indirectly<fp64_set>};
  q.single_task(props, [=] {
    Storage->foo();
  });
} else {
  auto props = syclext::properties{syclext::calls_indirectly<regular_set>};
  q.single_task(props, [=] {
    Storage->bar();
  });
}

```

This example should work regardless of whether target device supports 'fp64'
aspect or not. To achieve that, virtual member functions are outlined into
separate device images which are linked at runtime depending on whether they are
compatible with a target device.

Regardless of device code split mode selected by a user, functions marked with
`indirectly_callable` property should be outlined into a separate device images
by `sycl-post-link` tool based on the property argument.

Additionally, if any virtual function in such device image uses any optional
kernel features, then the whole image should be cloned with all function bodies
emptied. This cloned device image will be further referred to as "dummy virtual
functions device image".

This dummy device image is needed to support the example showed above when a
kernel creates an object of a polymorhpic class where some of virtual functions
use optional features. LLVM IR generated by front-end will contain a vtable,
which references all methods of the class. However, not all of them can be
directly included into kernel's device image to avoid speculative compilation.

When such kernel is submitted to a device, runtime will check which optional
features are supported and link one or another device image with virtual
functions.

#### New device image properties

To let runtime know which device images should be linked together to get virtual
functions working, new property set is introduced: "SYCL/virtual functions".

For device images, which contain virtual functions (i.e. ones produced by
outlining `indirectly_callable` functions into a separate device image), the
following properties are set within the new property set:
- "virtual-functions-set" with a string value containing name of virtual
  functions set contained within the image (value of the property argument);
- "dummy-image=1" if an image is a dummy virtual functions device image;

For other device images, the following properties are set within the new
property set:
- "calls-virtual-functions-set" with a string value containing comma-separated
  list of names of virtual function sets used by kernels in the image (as
  indicated by `calls_indirectly` kernel property);
- "creates-virtual-functions-set" with a string value containing comma-separate
  list of names of virtual function sets which are referenced from functions
  included into vtables used by a kernel within a device image;
  **TODO:** this item definitely needs better description

### Changes to the runtime

When a kernel submitted to a device comes from a device image with some
properties set in "SYCL/virtual functions" property set, then runtime does some
extra actions to link several device images together to ensure that the kernel
can be executed.

Algorithm for discovery of device images which has to be linked:
- if device image has property "calls-virtual-functions-set=A,B,...,N" on it,
  then all device images with "virtual-functions-set" property equal to "A",
  "B", ..., "N" are taken to be linked with the initial device image;
- if device image has property "creates-virtual-functions-set=A,B,...,N" on it,
  then for each device image with "virtual-functions-set" property equal to "A",
  "B", ..., "N" and *without* "dummy-image=1" property on it:
  - if that device image is compatible with device, it is taken to be linked
    with the initial device image;
  - otherwise, runtime looks for a device image with the same
    "virtual-functions-set" property, but *with* "dummy-image=1" property on it
    and takes that device image to be linked with the initial device image;

Produced list of device images is then linked together and used to enqueue a
kernel.

**TODO:** do we need to say anything about in-memory and on-disk cache
functionality here?

[1]: <../extensions/proposed/sycl_ext_oneapi_virtual_functions.asciidoc>
[2]: <CompileTimeProperties.md>
[3]: https://clang.llvm.org/docs/LanguageExtensions.html#builtin-sycl-unique-stable-name

